# -*- coding: utf-8 -*-
"""NNAlgorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1keY-ws8jVCFr7OuwhHCl3R9O5M_O4s0S
"""

# импортируем библиотеки

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow import keras
import bisect as bi

# загружаем тестовые данные

df = pd.read_excel('/content/drive/MyDrive/Диплом/dataSets/3_5_6_15/test.xlsx')
x_test = df[['x1', 'x2', 'x3', 'x4', 'x5', 'x6']].values
y_test = df['y'].values

# загружаем модель нейронной сети и историю

name_model = '10-10-10:3_5_6_15'
model = keras.models.load_model('/content/drive/MyDrive/Диплом/models2/'+name_model)
#model.summary()
hist_df = pd.read_excel('/content/drive/MyDrive/Диплом/histories/'+name_model+'.xlsx')

# загружаем веса или сохраняем модель нейронной сети

print(hist_df['val_mae'].idxmin())
#model.load_weights('/content/drive/MyDrive/Диплом/weights/'+name_model+'/4000.hdf5')
#model.save('/content/drive/MyDrive/Диплом/models2/'+name_model)

print(model.evaluate(x_test, y_test))

# Точность модели
plt.figure(figsize=(10, 5))
plt.plot(hist_df['mae'])
plt.plot(hist_df['val_mae'])
plt.yscale('log')
plt.title('Точность нейросети DS3:'+name_model)
plt.ylabel('точность')
plt.xlabel('эпохи')
plt.grid(True)
plt.legend(['тренировочная', 'валидационная'])
plt.show()

# Потери модели
plt.figure(figsize=(10, 5))
plt.plot(hist_df['loss'])
plt.plot(hist_df['val_loss'])
plt.yscale('log')
plt.title('Потери нейросети DS3:'+name_model)
plt.ylabel('потери')
plt.xlabel('эпохи')
plt.grid(True)
plt.legend(['тренировочные', 'валидационные'])
plt.show()

# Ошибка модели
d = model.predict(x_test)
d = d.reshape(d.shape[0]) - y_test
plt.figure(figsize=(10, 5))
plt.hist(d, bins=100, log=True)
plt.title('Ошибка нейросети DS3:'+name_model)
plt.ylabel('количество')
plt.xlabel('отклонение')
plt.grid(True)
plt.show()

# модуль с функциями

from math import *

def f1(x):
    return 1/6*x**6 - 52/25*x**5 + 39/80*x**4 + 71/10*x**3 - \
        79/20*x**2 - x + 1/10

def f2(x):
    return sin(x) + sin(10*x/3)

def f3(x):
    sum = 0
    for k in range(1, 6):
        sum += k*sin((k + 1)*x + k)
    return -sum

def f4(x):
    return -(16*x**2 - 24*x + 5)*exp(-x)

def f5(x):
    return (3*x - 1.4)*sin(18*x)

def f6(x):
    return -(x + sin(x))*exp(-x**2)

def f7(x):
    return sin(x) + sin(10*x/3) + log(x) - 0.84*x + 3

def f8(x):
    sum = 0
    for k in range(1, 6):
        sum += k*cos((k + 1)*x + k)
    return -sum

def f9(x):
    return sin(x) + sin(2*x/3)

def f10(x):
    return -x*sin(x)

def f11(x):
    return 2*cos(x) + cos(2*x)

def f12(x):
    return sin(x)**3 + cos(x)**3

def f13(x):
    return -pow(x, 2/3) - pow(-x**2 + 1, 1/3)

def f14(x):
    return -exp(-x)*sin(2*pi*x)

def f15(x):
    return (x**2 - 5*x + 6)/(x**2 + 1)

def f16(x):
    return 2*(x - 3)**2 + exp(0.5*x**2)

def f17(x):
    return x**6 - 15*x**4 + 27*x**2 + 250

def f18(x):
    if x <= 3:
        return (x - 2)**2
    return 2*log(x - 2) + 1

def f19(x):
    return -x + sin(3*x) - 1

def f20(x):
    return (sin(x) - x)*exp(-x**2)

func = [(f1, -1.5, 11), (f2, 2.7, 7.5), (f3, -10, 10), (f4, 1.9, 3.9),
    (f5, 0, 1.2), (f6, -10, 10), (f7, 2.7, 7.5), (f8, -10, 10), (f9, 3.1, 20.4), (f10, 0, 10),
    (f11, -1.57, 6.28), (f12, 0, 6.28), (f13, 0.001, 0.99), (f14, 0, 4), (f15, -5, 5),
    (f16, -3, 3), (f17, -4, 4), (f18, 0, 6), (f19, 0, 6.5), (f20, -10, 10)]

# модуль нейросетевого алгоритма

# переменная, означающая номер тестируемой функции. Отсчет с нуля. Для дебага
i_global = -1

class Point():
    def __init__(self, x, z):
        self.x = x
        self.z = z
    def __repr__(self):
        return f"Point({self.x}, {self.z})"
    def __str__(self):
        return f"Point({self.x}, {self.z})"
    def __lt__(self, other):
        return self.x < other.x

def step1(w, k, KSI, r, mu, a, b, network):
    gamma = [0.1]*(k + 1)
    lam = [0.1]*(k + 1)

    # X^max = max{x_i - x_i-1}
    Xmax = -1
    for i in range(1, k + 1):
        if w[i].x - w[i - 1].x > Xmax:
            Xmax = w[i].x - w[i - 1].x
    
    # lambda^max = max|z_i - z_i-1|/(x_i - x_i-1)
    lmax = -1
    for i in range(1, k + 1):
        cur = abs(w[i].z - w[i - 1].z) / (w[i].x - w[i - 1].x)
        if cur > lmax:
            lmax = cur
    
    for i in range(1, k + 1):
        gamma[i] = lmax * (w[i].x - w[i - 1].x) / Xmax
    
    # lambda_i = |z_i - z_i-1|/(x_i - x_i-1)
    for i in range(1, k + 1):
        lam[i] = abs(w[i].z - w[i - 1].z) / (w[i].x - w[i - 1].x)
    
    lmax1 = lmax if abs(lmax) > 1e-8 else 1e-8
    #xx = np.zeros((k, 6))
    xx = np.zeros((k, 3))
    for i in range(1, k + 1):
        xx[i - 1] = np.array([lam[i - 1]/lmax1 if i != 1 else 0,
                          lam[i]/lmax1,
                          lam[i + 1]/lmax1 if i != k else 0
                          #(w[i - 1].x - w[i - 2].x)/(b - a) if i != 1 else 0,
                            #(w[i].x - w[i - 1].x)/(b - a),
                            #(w[i + 1].x - w[i].x)/(b - a) if i != k else 0
                          #(w[i - 1].x - w[i - 2].x)/Xmax if i != 1 else 0,
                            #(w[i].x - w[i - 1].x)/Xmax,
                            #(w[i + 1].x - w[i].x)/Xmax if i != k else 0
                          ])
    an = network.predict(xx)
    for i in range(1, k + 1):
        mu[i] = r * max(an[i - 1][0] * lmax, gamma[i], KSI)
    #print(f"\tk={k}, xx = {xx}, lmax={lmax}, an={an}, mu={mu}")
    
def step2_3(w, k, mu):
    t = -1
    Rmin = 0
    for i in range(1, k + 1):
        R = (w[i].z + w[i - 1].z)/2 - mu[i]*(w[i].x - w[i - 1].x)/2
        if t == -1 or R < Rmin:
            t = i
            Rmin = R
    return t
    
def argminf(w, k):
    imin = 0
    for i in range(0, k + 1):
        if w[i].z < w[imin].z:
            imin = i
    return imin

def odii(f, a, b, EPS, KSI, r, network):
    # Константа для инициализация
    INF = 1000000000000.0

    # пары (x_i, z_i=f(x_i))
    w = [Point(INF, INF)] * 2
    mu = [INF] * 2

    # Шаг 0
    w[0] = Point(a, f(a))
    w[1] = Point(b, f(b))
    k = 1
    while True:
        # Шаг 1
        step1(w, k, KSI, r, mu, a, b, network)

        # Шаг 2, 3
        t = step2_3(w, k, mu)
    
        # Шаг 4
        if k == 10000 or abs(w[t].x - w[t - 1].x) <= EPS:
            imin = argminf(w, k)
            return (w[imin].x, w[imin].z, k)
    
        # Шаг 5
        x_next = (w[t].x + w[t - 1].x)/2 - (w[t].z - w[t - 1].z)/(2*mu[t])
        # Если новая точка вышла за пределы отрезка [a, b]
        #if x_next > b or x_next < a:
        #    print(f"\tТочка вышла за пределы отрезка:", end=' ')
        #print(f"\tx_next = {x_next}")
        
        # Вставка новой точки и перенумерация x_i
        bi.insort(w, Point(x_next, f(x_next)))
        mu.append(INF)
        #print(k)
        k += 1

# запускаем нейросетевой алгоритм

def commaReplace(x):
    s = list(str(x))
    n = len(s)
    for i in range(n):
        if s[i] == '.':
            s[i] = ','
    return ''.join(s)

with open("/content/drive/MyDrive/Диплом/results/1.txt", "w") as fout:
    n = len(func)
    for i in range(n):
        f = func[i][0]
        a = func[i][1]
        b = func[i][2]
        i_global = i
        x_min, f_min, k = odii(f, a, b, 1e-4*(b - a), 1e-6, 1.1, model)
        fout.write(f"{k + 1}\t{commaReplace(x_min)}\t{commaReplace(f_min)}")
        if i < n - 1:
            fout.write("\n")
        print(f"{i + 1}/20")